package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"fmt"
	"nf-shard-orchestrator/graph/model"
	"nf-shard-orchestrator/pkg/runner"
)

// RunJob is the resolver for the runJob field.
func (r *mutationResolver) RunJob(ctx context.Context, input model.RunJobCommand) (*model.RunJobResponse, error) {
	r.Logger.Debug("Received request to launch workflow")

	run := runner.RunConfig{
		Args:           input.Args(),
		PipelineUrl:    input.PipelineURL,
		ConfigOverride: input.Executor.ComputeOverride,
	}

	err := runner.RemoveNfAssetsDir()
	if err != nil {
		r.Logger.Error("run", "error", err)
		return nil, err
	}

	err = runner.MockExecute(ctx, r.Logger, run, r.NFService.BinPath())
	if err != nil {
		r.Logger.Error("run", "error", err)
		return nil, err
	}

	runName := runner.GenerateRunName()
	run = run.SetRunName(runName)

	r.Logger.Info("job starting")
	var processId string
	switch input.Executor.Name {
	case "float":
		processId, err = r.FloatService.Execute(run)
	case "awsbatch", "google-batch":
		processId, err = r.NFService.Execute(run)
	default:
		r.Logger.Error("Invalid executor", "executor", input.Executor.Name)
	}

	if err != nil {
		r.Logger.Error("run", "error", err)
		return nil, err
	}

	r.Logger.Info("process running", "process_id", processId)

	return &model.RunJobResponse{
		Status:     true,
		ProcessKey: processId,
		Executor:   input.Executor.Name,
		RunName:    runName,
	}, nil
}

// TerminateJob is the resolver for the terminateJob field.
func (r *mutationResolver) TerminateJob(ctx context.Context, input model.TerminateJobCommand) (bool, error) {
	r.Logger.Debug("Received request to stop job")

	terminate := runner.StopConfig{
		ProcessId:  input.ProcessKey,
		RunnerName: input.Executor,
	}

	var err error
	switch input.Executor {
	case "float":
		err = r.FloatService.Stop(terminate)
	case "awsbatch", "google-batch":
		err = r.NFService.Stop(terminate)
	default:
		return false, errors.New("could not find executor")
	}

	if err != nil {
		r.Logger.Error("stop process", "error", err)
		return false, err
	}

	return true, nil
}

// HealthCheck is the resolver for the healthCheck field.
func (r *queryResolver) HealthCheck(ctx context.Context) (bool, error) {
	fmt.Println("healh check now")
	return true, nil
}

// CheckStatus is the resolver for the checkStatus field.
func (r *queryResolver) CheckStatus(ctx context.Context) (bool, error) {
	return true, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
